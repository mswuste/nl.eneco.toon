'use strict';

const Homey = require('homey');
const _ = require('underscore');
const uuid = require('uuid/v4');
const EventEmitter = require('events');
const request = require('request-promise-native');

class OAuth2Account extends EventEmitter {

	/**
	 * Construct a OAuth2Account instance, that will handle fetching and refreshing access tokens.
	 * @param {Object} options
	 * @param {string} [options.id] - OAuth2 account identifier, or auto-generated uuid
	 * @param {OAuth2Client} [options.oauth2Client] - OAuth2Client associated with this OAuth2Account
	 * @param {string} [options.refreshingEnabled = true] - OAuth2 refresh grant enabled
	 * @param {string} [options.refreshToken] - OAuth2 refresh token
	 * @param {string} [options.accessToken] - OAuth2 access token
	 * @param {Date} [options.expiresIn] - Date object indicating when access token expires
	 */
	constructor(options = {}) {
		super();

		this.id = options.id || uuid();

		// Fix circular references
		this.oauth2Client = options.oauth2Client.getStoreValues();

		// Determine if refreshing is enabled
		this.refreshingEnabled = (options.hasOwnProperty('refreshingEnabled')) ? options.refreshingEnabled : true;

		// Use provided log function or default console.log
		this._log = options.log || console.log;

		// Store tokens for later retrieval
		this.accessToken = options.accessToken || Homey.ManagerSettings.get(`oauth2_${this.id}_accessToken`);
		this.refreshToken = options.refreshToken || Homey.ManagerSettings.get(`oauth2_${this.id}_refreshToken`);
		this.expiresIn = options.expiresIn || Homey.ManagerSettings.get(`oauth2_${this.id}_expiresIn`);

		// If expiresIn was fetched from storage, create new date object
		if (typeof this.expiresIn === 'string') this.expiresIn = new Date(this.expiresIn);

		// Hijack log method
		this.log = (...args) => {
			args.unshift('[OAuth2Account]');
			this._log.apply(null, args);
		};

		this.log(`new OAuth2Account constructed (id: ${this.id})`);

		// Register cron job for refreshing tokens if expire date passed immediately refresh
		if (this.expiresIn) this.setRefreshTokenTimeout(this._getExpiresInSeconds(this.expiresIn));
	}

	/**
	 * Method that returns the OAuth2Url belonging to this OAuth2Account.
	 * @returns {string}
	 */
	getOAuth2Url() {
		return this.oauth2Client.oauth2Url;
	}

	/**
	 * Returns important values that should be stored persistently.
	 * @returns {Object}
	 */
	getStoreValues() {
		return _.pick(this, 'accessToken', 'refreshToken', 'expiresIn', 'oauth2Client');
	}

	/**
	 * Method that will clean up event listeners and unsets storage settings.
	 */
	destroy() {
		if (this.refreshTokensTimeout) clearTimeout(this.refreshTokensTimeout);
		Homey.ManagerSettings.unset(`oauth2_${this.id}_accessToken`);
		Homey.ManagerSettings.unset(`oauth2_${this.id}_refreshToken`);
		Homey.ManagerSettings.unset(`oauth2_${this.id}_expiresIn`);
		this.removeAllListeners();
		this.log(`OAuth2Account destroyed (id: ${this.id})`);
	}

	/**
	 * Getter for accessToken.
	 * @returns {string}
	 */
	get accessToken() {
		return this._accessToken;
	}

	/**
	 * Setter for accessToken, also stores it in persistent storage.
	 * @param {string} accessToken - new access token
	 */
	set accessToken(accessToken) {
		Homey.ManagerSettings.set(`oauth2_${this.id}_accessToken`, accessToken);
		this._accessToken = accessToken;
	}

	/**
	 * Getter for refreshToken.
	 * @returns {string}
	 */
	get refreshToken() {
		return this._refreshToken;
	}

	/**
	 * Setter for refreshToken, also stores it in persistent storage.
	 * @param {string} refreshToken - new refresh token
	 */
	set refreshToken(refreshToken) {
		Homey.ManagerSettings.set(`oauth2_${this.id}_refreshToken`, refreshToken);
		this._refreshToken = refreshToken;
	}

	/**
	 * Setter for expiresIn, stores it in persistent storage.
	 * @param {Date} expiresIn - Date when access token expires
	 */
	set expiresIn(expiresIn) {
		Homey.ManagerSettings.set(`oauth2_${this.id}_expiresIn`, expiresIn);
		this._expiresIn = expiresIn;
	}

	/**
	 * Getter for expiresIn.
	 * @returns {Date}
	 */
	get expiresIn() {
		return this._expiresIn;
	}

	/**
	 * Method that sets access token and refresh token and then emits
	 * the token event to update all listeners.
	 * @param {Object} tokens
	 * @param {string} tokens.accessToken
	 * @param {string} [tokens.refreshToken]
	 * @param {Date} [tokens.expiresIn]
	 */
	setTokens(tokens) {
		this.accessToken = tokens.accessToken;
		if (tokens.hasOwnProperty('refreshToken')) this.refreshToken = tokens.refreshToken;
		if (tokens.hasOwnProperty('expiresIn')) this.expiresIn = tokens.expiresIn;
		if (tokens.hasOwnProperty('expiresIn') && this.refreshingEnabled) {
			this.setRefreshTokenTimeout(this._getExpiresInSeconds(this.expiresIn));
		}
		this.emit('tokens', tokens);
	}

	/**
	 * Method that performs a request to retrieve access tokens.
	 * @param {string} code - OAuth2 code
	 * @returns {Promise}
	 */
	getAccessTokens(code) {
		this.log(`get access tokens (code: ${code}, id: ${this.id})`);
		return new Promise((resolve, reject) => {
			request({
				url: this.oauth2Client.tokenEndpoint,
				method: 'POST',
				json: true,
				form: {
					grant_type: 'authorization_code',
					client_id: this.oauth2Client.key,
					client_secret: this.oauth2Client.secret,
					redirect_uri: 'https://callback.athom.com/oauth2/callback/',
					code,
				},
			})
				.then(body => this._processNewAccessTokens(body, resolve, reject))
				.catch(err => {
					this.log(`failed to fetch access tokens (id: ${this.id})`, err);
					return reject(err);
				});
		});
	}

	/**
	 * Method that performs a request that will refresh the access tokens.
	 * @returns {Promise}
	 */
	refreshAccessTokens() {
		this.log(`refresh access tokens (id: ${this.id})`);
		return new Promise((resolve, reject) => {

			if (!this.refreshToken) return reject(new Error('missing_refresh_token'));

			request({
				url: this.oauth2Client.tokenEndpoint,
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
				},
				json: true,
				form: {
					client_secret: this.oauth2Client.secret,
					client_id: this.oauth2Client.key,
					grant_type: 'refresh_token',
					refresh_token: this.refreshToken,
				},
			})
				.then(body => this._processNewAccessTokens(body, resolve, reject))
				.catch(err => {
					this.log(`failed to refresh access tokens (id: ${this.id})`, err);
					return reject(err);
				});
		});
	}

	/**
	 * Method that sets a timeout for the next refresh of tokens.
	 * @param {number} refreshTimeoutSeconds - Timeout when tokens need to be refreshed in seconds
	 */
	setRefreshTokenTimeout(refreshTimeoutSeconds) {
		this.log(`set refresh token timeout for ${refreshTimeoutSeconds} seconds (id: ${this.id})`);

		// Set refresh access token timeout
		if (this.refreshTokensTimeout) clearTimeout(this.refreshTokensTimeout);
		this.refreshTokensTimeout = setTimeout(() => {
			this.log(`execute refresh token timeout (id: ${this.id})`);
			this.refreshAccessTokens();
		}, refreshTimeoutSeconds * 1000);
	}

	/**
	 * Method that converts expiresIn Date to number of seconds until expiry minus one minute.
	 * @param {Date} expiresIn - Seconds till expiry
	 * @returns {number} - Seconds till expiry from this moment
	 * @private
	 */
	_getExpiresInSeconds(expiresIn) {
		return Math.max(((expiresIn - new Date()) / 1000) - 60, 0);
	}

	/**
	 * Method that searches the body for new access tokens, and sets a timeout to refresh the tokens
	 * in time. It emits 'tokens' to update listeners of the new tokens.
	 * @param body
	 * @param resolve
	 * @param reject
	 * @returns {Promise|Error}ºª
	 * @private
	 */
	_processNewAccessTokens(body, resolve, reject) {

		// Check for invalid body
		if (!body || !body.hasOwnProperty('access_token') ||
			(this.refreshingEnabled && !body.hasOwnProperty('refresh_token'))) {
			this.log(`error processing new access tokens (id: ${this.id})`, body);
			return reject(new Error('invalid_tokens_object_received'));
		}

		this.log(`fetched new access tokens (id: ${this.id})`);

		// Store new tokens
		this.accessToken = body.access_token;
		if (body.hasOwnProperty('refresh_token')) this.refreshToken = body.refresh_token;
		if (body.hasOwnProperty('expires_in')) {

			// Convert seconds to date
			const t = new Date();
			t.setSeconds(t.getSeconds() + body.expires_in);
			this.expiresIn = t;
		}

		// Construct tokens object
		const tokens = {
			accessToken: this.accessToken,
		};

		// Add to tokens object if available
		if (body.hasOwnProperty('refresh_token')) tokens.refreshToken = this.refreshToken;
		if (body.hasOwnProperty('expires_in')) tokens.expiresIn = this.expiresIn;

		// If refreshing is possible
		if (this.refreshingEnabled) this.setRefreshTokenTimeout(this._getExpiresInSeconds(this.expiresIn));

		// Emit refreshed event
		this.emit('tokens', tokens);

		// Resolve new tokens
		return resolve(tokens);
	}
}

module.exports = OAuth2Account;
